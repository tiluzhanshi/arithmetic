1.数据结构+算法=程序  
2.问题求解  
2.1.编写计算机程序的目的？  
解决实际的应用问题  
2.2.问题抽象  
分析和抽象任务需求，建立问题模型  
2.3.数据抽象
确定恰当的数据结构表示数学模型  
2.4.算法抽象
在数据模型的基础上设计合适的算法
2.5.数据结构+算法，进行程序设计
模拟和解决实际问题
3.数据结构
3.1.结构：实体+关系
3.2.数据结构
　　①　按照逻辑关系组织起来的一批数据；
　　②　按一定的存储方法把它存储在计算机中
　　③　在这些数据上定义了一个运算的集合

3.3.数据结构关注三个方面
　　①　逻辑结构
　　②　物理结构（存储结构）
　　③　数据的运算

3.4.线性表（Linear List）
3.4.1.定义
线性表是具有相同数据类型的n(n≥0)个数据元素的有限序列，其中n为表长，当n=0时线性表是一个空表。若用L命名线性表，则其一般表示为
　　　　　　　　　　　　　L=(a1, a2, ..., ai, ai+1 ,..., an)
　　①　表头元素
　　②　表尾元素
　　③　直接前驱
　　④　直接后继

线性表是抽象性的定义；
3.4.2.基本操作
　　①　创建
　　②　销毁
　　③　插入
　　④　删除
　　⑤　按值查找：在表中查找给定关键字的值
　　⑥　按位查找：在表中查找第i位的值
在实际开发中，还可以增加一些其它的方法；
对上的定义的方法名和参数的数据类型并没有做严格要求，上面这个方法的描述是具有抽象描述的；
3.4.3.线性表的数据元素
　　①　顺序存储
　　②　链接存储
　　③　散列存储
必要时，还可以为数据元素建立索引表，进行索引存储；
3.4.4.为什么要实现对数据结构的基本操作？
　　①　团队合作编程的数据结构要让别人能够很方便的使用（封装）；
　　②　将常用的操作/运算封装成函数，避免重复工作，降低出错风险；
3.5.顺序表
3.5.1.定义
用顺序存储的方式实现线性表顺序存储。把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现；
3.5.2.顺序表的实现——静态分配
使用数组的形式表示，缺点是在初始时就分配了内存大小；
3.5.3.顺序表的实现——动态分配
3.5.4.基本操作
3.6.单链表
3.6.1.定义
3.6.2.基本操作

3.7.堆(heap)
3.7.1.定义
堆也是一种树状的数据结构（不要跟内存模型中的“堆空间”混淆）
堆(二叉堆)是一种特殊的二叉树，二叉堆是完全二叉树或者是近似完全二叉树；
3.7.1.1.二叉堆满足二个特性：
　　①　父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值；
　　②　每个节点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）；
3.7.1.2.最大堆和最小堆
　　①　何意节点的值都大于其子节点的值——大顶堆；
　　②　何意节点的值都小于其子节点的值——小顶堆；

二叉堆是计算机科学中一种非常著名的数据结构，由于它能高效、快速地找出最大值和最小值，常被应用于优先队列。
结构性：使用数组来表示完全二叉树。
有序性：最大堆 和 最小堆
3.7.2.二叉堆分类
　　①　二叉堆(Binary Heap，完全二叉堆)
　　②　多叉堆(D-heap, D-ary Heap)
　　③　索引堆(Index Heap)
　　④　二项堆(Binomial Heap)
　　⑤　斐波那契堆(Fibonacci Heap)
　　⑥　左倾堆(Leftist Heap,左式堆)
　　⑦　斜堆(Skew Heap)
3.7.3.索引i的规律（n是元素数量）
　　①　如果i=0,它是根节点；
　　②　如果i>0,它的父节点索引是floor((i-1)/2);
　　③　如果2i + 1 ≤ n - 1, 它的左子节点索引为 2i + 1;
　　④　如果2i + 1 > n -1, 它无左子节点；
　　⑤　如果2i + 2 ≤ n - 1, 它的右子节点索引为 2i + 2;
　　⑥　如果2i + 2 > n -1, 它无右子节点；

3.7.4.二叉堆接口定义
　　①　Number size();
　　②　Boolean isEmpty();
　　③　Void add()
　　④　Void clear()
　　⑤　Void remove()
　　⑥　Void replace()
3.7.5.实例场景
　　①　在银行取号排队时，普通的号是A007，VIP用户的号是V007，在银行叫号时V007的优先级高于A007；
　　②　打印机在打印东西时，有一个需要打印100页的文档时，需要打印一个3页的重要文档，这里需要调整优先级，需要优先打开3页的；


3.8.树、二叉树
3.8.1.定义
3.8.1.1.完全二叉树
规则是：从上到下从左到右的特点
3.8.1.2.完美二叉树（满二叉树）
3.8.1.3.非完全二叉树
3.8.2.树（树林）的遍历
　　①　按度方向
　　②　深度方向
　　a)先根次序（先根后子女）
　　b)后根次序（先子女后根）
3.8.3.二叉树的遍历方法
3.8.3.1.先序——根、左子树、右子树
　　①　访问根结点
　　②　先序遍历其左子树
　　③　先序遍历其右子树
3.8.3.2.中序——左子树、根、右子树
　　①　中序遍历其左子树
　　②　访问根结点
　　③　中序遍历其右子树
3.8.3.3.后序——左子树、右子树、根
　　①　后序遍历其左子树
　　②　后序遍历其右子树
　　③　访问根结点
3.8.3.4.层次遍历——从上到下、从左到右
队列实现：遍历从根结点开始，首先将根结点入队，然后开始执行循环：结点出队、访问该结点、其左右儿子入队；
　　①　从队列中取出一个元素；
　　②　访问该元素所指结点；
　　③　若该元素所指结点的左、右孩子结点非空，则将其左、右孩子的指针顺序入队；
3.8.3.5.总结
先序、中序、后序遍历过程：遍历过程中经过结点的路线一样，只是访问各结点的时机不同；用递归的方式来实现的

3.8.4.二叉树的存储方式
3.8.4.1.顺序存储
　　①　完全二叉树
　　存储在数组中，从上到下，从左到右存放在一维数组中。
　　②　非完全二叉树
　　非完全二叉树先要转换成完全二叉树，再进行完全二叉树的存储。
3.8.4.2.链表存储
3.8.5.中序遍历非递归遍历算法
　　基本思想：使用堆栈
　　①　遇到一个结点，就抒它压栈，并去遍历它的械子树；
　　②　当左子树遍历结束后，从栈顶弹出这个结点并访问它；
　　③　然后按其右指针再去中序遍历该结点的右子树；
3.8.6.二叉树的检索、插入、删除运算
3.8.6.1.查找（检索）
3.8.6.2.插入
3.8.6.3.删除
3.9.平衡二叉树
3.9.1.定义
平衡树(Balance Tree，BT) 指的是，任意节点的子树的高度差都小于等于1。常见的符合平衡树的有，B树（多路平衡搜索树）、AVL树（二叉平衡搜索树）等。平衡树可以完成集合的一系列操作, 时间复杂度和空间复杂度相对于“2-3树”要低，在完成集合的一系列操作中始终保持平衡，为大型数据库的组织、索引提供了一条新的途径。


3.10.图
3.10.1.定义：
表示一种“多对多的”关系
3.10.2.怎么在程序中表示图
3.10.3.六度空间理论(Six Degrees of  Separation)
3.10.4.常见术语
　　1．无向图
　　2．有向图

3.10.5.案例
图书馆查询书、社交网络、一个地方到别一个地方最短路径

4.算法
4.1.算法的特性
1. 有限性(有穷性)：有限步骤之内正常结束，不能形成无穷循环。程序可以是无穷的。 
2.确定性：算法中的每一个步骤必须有确定含义，无二义性。 算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出；
3.可行性：算法中描述的操作都可以通过已实现的基本运算执行有限次业实现。原则上能精确进行，操作可通过已实现的基本运算执行有限次而完成。 
4.输入：有多个或0个输入，这些输入取自于某个特定的对象集合。
5.输出：至少有一个或多个输出，这些输出是与输入有着某种特定关系的量。
在算法的五大特性中，最基本的是有限性、确定性和可行性这三个特性。
4.2.算法设计要求

4.2.1.正常性
　　①　无语法错误
　　②　对n组输入产生正确的结果
　　③　对特殊输入产生正确的结果
　　④　对所有输入产生正确的结果
4.2.2.可读性
算法主要是为了人的阅读与交流
4.2.3.健壮性
不同的输入都要有相应的反应。输入非法数据时，算法能适当地做出反应或处理，而不会产生莫名其妙的输出结果；
4.2.4.高效与低存储量
执行速度快，时间复杂度低；
4.3.什么是好的算法
4.3.1.时间复杂度T(n)
根据算法写成的程序在执行时耗费时间的长度。这个长度往往也与输入数据的规模有关。时间复杂度过高的低效算法可能导致我们在有生之年都等不到运行结果；
运行的时间过长
4.3.2.空间复杂度S(n)
根据算法写成的程序在执行时占用存储单元的长度。这个长度往往与输入数据的规模有关。空间复杂度过高的算法可能导致使用的内存超限，造成程序非正常中断；
占用内存过大
4.4.时间复杂度下界
对于冒泡和插入排序是有时间 复杂度下界的；
对于下标i<j,如果A[i]>A[j],则称(i,j)是一对逆序对（inversion）
问题：序列{34，8，64，51，32，21}中有多少逆序对？

4.5.分而治之
　　①　分解原问题为多个子问题（原问题的多个小实例）
　　②　解决子问题，用返回解决子问题的方式的递归算法。递归算法的基本情形可以用来解决子问题
　　③　组合这些子问题的解决方式，得到原问题的解
4.6.冒泡排序




1.问题的分类
　　①　What：是什么？面向判断与分类的问题；
　　②　Why：为什么？面向求因与证明的问题；
　　③　How：怎么做？面向过程与构建的总是；

当遇到一个问题时，都要考虑那些因素，如何考虑问题
2.计算机科学
计算机科学不仅仅是对计算机的研究；
计算机科学主要研究的是问题、问题解决过程、以及问题的解决方案；
3.什么是抽象？例子：汽车
　　①　从司机观点来看，汽车是一台可以带人去住目的地的代步工具。
　　司机上车，点火，换档，踩油门加速，刹车
　　②　从抽象角度说，司机看到洗车的“逻辑”层次
　　司机可以通过操作各个机构来达到运输的目的
　　③　这些操作机构（方向盘、油门、档位）就称为“接口Interface”
　　④　而从汽车修理工的角度来看同一辆汽车，就会相当不同，他还需要清楚每项功能是如何实现的；
　　如发动机工作原理，档位操作的机械结构，发动机舱内各处温度如何测量和控制等等
　　⑤　这些内部构造成了汽车的”物理“层次；
　　⑥　工作过程就称为”实现Implementation”






